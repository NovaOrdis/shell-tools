#!/usr/bin/env bash

BASH_SHLIB_VERSION=1.0.5

#
# Generic bash functionality
#

export VERBOSE=false
export HELP=false
export SEPARATOR=$'\x1f' # US - unit separator
export DEBUG_OUTPUT

#
# The global array that maintains the remaining "non-common" arguments, to be re-set as positional arguments.
#
declare -a ARGS

#
# A function that extracts common arguments such as "--verbose", "-v", "help", "--help" or "version" from the command
# line arguments and sets the appropriate global variables, while setting the remaining command line arguments as
# elements of a global array.
#
# In some cases, process-common-arguments() executes an internal command and exists, as it is the case for "version":
# the content of the VERSION variable is displayed at stdout and the function invokes exit 0.
#
#
# Option Handled       Global Variable Set     Action
#
# -v, --verbose        export VERBOSE=true     none
# -h, --help, help     export HELP=true        node
# version              N/A                     Display ${VERSION} and exit 0
#
# To restore all arguments that have not been processed, as positional arguments, use as as shown below:
#
# process-common-arguments "$@" && set -- "${ARGS[@]}" || { echo "failed to process common arguments" 1>&2; exit 1; }
#
# Help Pattern:
#
# process-common-arguments() sets HELP=true if it sees help|--help|-h among its arguments, and removes the argument from
# the list. This approach allows commands to display help regardless of the relative order of the command and the help
# argument on the command line.
#
#
function process-common-arguments() {

    declare -a | grep -q "declare -a ARGS" || { error "${FUNCNAME[0]}(): 'ARGS' indexed array not declared"; exit 1; }

    local index=0

    while [[ $# -gt 0 ]]; do

        if [[ $1 = "--verbose" || $1 = "-v" ]]; then

            export VERBOSE=true

        elif [[ $1 = "help" || $1 = "--help" || $1 = "-h" ]]; then

            export HELP=true

        elif [[ $1 = "version" ]]; then

            local version=${VERSION}
            [[ -z ${version} ]] && version="N/A"
            echo ${version}
            exit 0

        else

            ARGS[${index}]=$1
            ((index++))

        fi

        shift

    done
}

#
# Gets the command line options and extracts the values of "interesting" options. The options to look for are passed
# as keys of an 'OPTIONS' associative array. The 'OPTIONS' associative array must be declared, allocated and have at
# least a value, otherwise process-options() will exit the shell with an error code.
#
# The keys of the 'OPTIONS' associative array are the option literals: if the option is --something, the key must be
# "--something" - must include the double dashes. If the option is -a, then the key is "-a" - must include the single
# dash, and so on.
#
# The values of the 'OPTIONS' associative array contain the option "specifications". A specification is a space
# separated list, passed as string. The specification contains, in order, the option type (as "string", "integer",
# "boolean") and then zero or more aliases, all space-separated.
#
# Boolean options: Only the option must be present to count as "true".
# Integer options: the values are checked to make sure they're numerals.
#
# The identified option values are returned within the same associative array. If more than one identical options
# are present on the command line, the last one wins.
#
# The function arguments that do not match any option are returned as content of the global ARGS array, in a pattern
# that is similar to the one used by the process-common-arguments() function.
#
# Usage:
#
#           declare -a ARGS
#           declare -A OPTIONS
#           OPTIONS["--path"]="string -p"
#           OPTIONS["--count"]="integer -c --COUNT"
#           OPTIONS["--debug"]="boolean"
#           process-options "$@"
#           fail-on-unknown-arguments
#
# If, for example, the arguments are "--debug --path something", 'OPTIONS' content will be:
#
# OPTIONS["--path"]="something"
# OPTIONS["--debug"]="true"
#
# TODO: Introduce equivalent --something=<value>, which should behave similarly to --something <value>
#
function process-options() {

    debug "${FUNCNAME[0]}($@)"

    declare -A | grep -q "declare -A OPTIONS" || { error "${FUNCNAME[0]}(): 'OPTIONS' associative array not declared"; exit 1; }
    [[ ${#OPTIONS[@]} -eq 0 ]] && { error "${FUNCNAME[0]}(): 'OPTIONS' associative array contains no values"; exit 1; }
    declare -a | grep -q "declare -a ARGS" || { error "${FUNCNAME[0]}(): 'ARGS' indexed array not declared"; exit 1; }

    local opt
    local arg
    local opt_spec
    local match
    local type
    local -a aliases
    local args_index=0

    declare -A results
    while [[ -n $1 ]]; do
        arg=$1
        debug "arg: ${arg}"
        match=false

        for opt in "${!OPTIONS[@]}"; do

            opt_spec=${OPTIONS[${opt}]}
            type=${opt_spec%% *}
            opt_spec=${opt_spec#${type}}
            read -r -a aliases <<< "${opt_spec}"
            aliases[${#aliases[@]}]=${opt}

            debug "opt: ${opt}"
            debug "type: ${type}"
            debug "aliases size: ${#aliases[@]}, aliases: ${aliases[@]}"

            for opt_alias in ${aliases[@]}; do

                if [[ ${arg} = ${opt_alias} ]]; then
                    #
                    # option match - either the main option or an alias
                    #
                    match=true
                    if [[ ${type} = "boolean" ]]; then
                        debug "${arg} matched boolean option and is being assigned to true"
                        results[${opt}]="true"
                    elif [[ ${type} = "string" ]]; then
                        shift
                        [[ -z $1 || ${1:0:1} = "-" ]] && { error "missing ${opt_alias} string value"; exit 1; }
                        results[${opt}]="$1"
                        debug "${arg} ${type} value set to ${results[${opt}]}"
                    elif [[ ${type} = "integer" ]]; then
                        shift
                        [[ -z $1 || ${1:0:1} = "-" ]] && { error "missing ${opt_alias} integer value"; exit 1; }
                        #
                        # check it's integer
                        #
                        if ! expr $1 + 1 >/dev/null 2>&1; then
                            error "${opt_alias} requires an integer value but got '$1'"
                            exit 1
                        fi
                        results[${opt}]=$1
                        debug "${arg} ${type} value set to ${results[${opt}]}"
                    else
                        error "${FUNCNAME[0]}(): invalid option type '${type}' for option ${opt_alias}"
                        exit 1;
                    fi
                    #
                    # do not break, continue processing, the last match wins
                    #
                fi
            done
        done
        if ! ${match}; then
            debug "${arg} matches no option"
            ARGS[${args_index}]=${arg}
            ((args_index++))
        fi
        shift
    done

    #
    # clear the 'OPTIONS' map and transfer the results
    #
    for opt in "${!OPTIONS[@]}"; do
        unset OPTIONS[${opt}]
    done
    for opt in "${!results[@]}"; do
        OPTIONS[${opt}]=${results[${opt}]}
    done
    unset results
}

#
# The function assumes that everything found in the ARGS indexed array are unknown arguments and exits the
# current shell with an error message and a non-zero exit code
#
function fail-on-unknown-arguments() {

    debug "${FUNCNAME[0]}($@)"

    [[ ${#ARGS[@]} -eq 0 ]] && return

    local header="unknown argument(s): "

    local message=${header}

    for a in "${ARGS[@]}"; do
        [[ ${message} = ${header} ]] && message="${message} ${a}" || message="${message}, ${a}"
    done

    error "${message}"
    exit 1
}
#
# Send the arguments to stderr and exits with a non-zero code (255)
#
function fail() {

    echo [failure]: $@ 1>&2
    exit 255
}

#
# Send error information at stderr, but do not exit and return 0 instead
#
function error {

    echo [error]: $@ 1>&2
    return 0
}

#
# Send a warning at stderr (not to interfere with function returns)
#
function warn {

    echo [warning]: $@ 1>&2
    return 0
}

#
# Send info at stderr (not to interfere with function returns)
#
function info {

    echo $@ 1>&2
    return 0
}

#
# If VERBOSE is set, send debug info at stderr (not to interfere with function returns) or to DEBUG_OUTPUT, if set.
#
# Recommended pattern to debug function calls:
#
#   debug "${FUNCNAME[0]}($@)"
#
function debug() {

    ! ${VERBOSE} && return 0
    [[ -z ${DEBUG_OUTPUT} ]] && echo $@ 1>&2 || echo $@ >> ${DEBUG_OUTPUT}
    return 0
}

#
# Creates a temporary directory with a random name (in a designated temporary area of the filesystem, usually /tmp) and
# returns its name. The caller must insure the directory is removed if not useful anymore, otherwise they will
# accumulate.
#
# Usage pattern:
#
#   local tmp_dir
#   tmp_dir=$(get-tmp-dir) || exit 1
#   ...
#
#   rm -r ${tmp_dir} && debug "deleted temporary directory ${tmp_dir}" || warn "failed to delete temporary directory ${tmp_dir}"
#
function get-tmp-dir() {

    debug "${FUNCNAME[0]}($@)"

    local name="/tmp/shell-tools-$(date +'%y%m%d%H%M%S')-${RANDOM}"

    mkdir ${name} || fail "failed to create temporary directory ${name}"

    debug "created temporary directory and returning ${name}"

    echo ${name}
}

#
# Turns a relative path to absolute path, returning the absolute path at stdout.
# If the path is already absolute, the function is a noop. The function does not attempt to validate the path in any
# way.
#
function to-absolute-path() {

    debug "${FUNCNAME[0]}($@)"

    local path=$1
    local abs_path

    [[ -z ${path} ]] && fail "${FUNCNAME[0]}($@) 'path' not provided"

    if [[ ${path:0:1} = "/" ]]; then

        abs_path=${path}

    else

        #
        # relative
        #

        path=${path#./}
        abs_path=$(pwd)/${path}
    fi

    debug "absolute path: ${abs_path}"


    #
    # remove trailing /.
    #

    abs_path=${abs_path%/.}
    echo ${abs_path}

}

#
# returns at stdout the major version of the bash running this code
#
# bash 3:
# GNU bash, version 3.2.57(1)-release (x86_64-apple-darwin18)
# Copyright (C) 2007 Free Software Foundation, Inc.
#
function bash-major-version() {

    bash --version | head -n 1 | sed -e 's/^.*version \(.\).*$/\1/'
}

#
# exit with a non-zero exit code if the local bash version is smaller than 4
#
function check-bash-version() {

    local bash_major_version
    bash_major_version=$(bash-major-version)
    debug "bash major version: ${bash_major_version}"
    if [ ${bash_major_version} -lt 4 ]; then echo "[error]: bash 4 or higher is required, please upgrade" 1>&2; exit 1; fi
}

#
# Pull an artifact from an URL. The URL can be remote (https://example.com/test.zip) or local (file:///tmp/test.zip,
# file://./test.zip)
#
function pull() {

    debug "${FUNCNAME[0]}($@)"

    local url=$1
}