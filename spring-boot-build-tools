#!/usr/bin/env bash

[[ -f $(dirname $0)/lib/bash.shlib ]] && . $(dirname $0)/lib/bash.shlib || { echo "$(dirname $0)/lib/bash.shlib not found" 1>&2; exit 1; }

function display-help() {

cat <<EOF

Build, test, deployment and execution tools.

'b' builds a Spring Boot project. The command must be invoked from project root.

    Usage:

        b [-c] [-r] [--no-tests]

    Options:

        -c - clean

        -r - refresh dependencies, equivalent to passing --refresh-dependencies
           to Gradle.

        --no-tests - do not run tests.


'r' runs (executes) the current project. The project can be a Spring Boot project,
a simple Gradle Java project that contains a main class, etc. In case of a Spring
Boot project, we assume we're in the project home of the Spring Boot microservice
and we run the "fat" JAR locally.

    Usage:

        r [common-options] -d|--debug --trace


    The runner supports an optional configuration file .rconfig in the project home
    directory. The configuration file may contain:

    * The active profile:

        active.profile=...



'd' deploys the application distribution, packaged as ZIP, as found under the
./build/distributions directory. The deployment consists in removing the old
version, and unpacking the new version. The script should be run from the root of
the project (or from the root of the root project).

EOF
}

function main()  {

    local command
    local link_name=$(basename $0)

    if [[ ${link_name} = "b" ]]; then

        command="build"

    elif [[ ${link_name} = "r" ]]; then

        command="run"

    elif [[ ${link_name} = "t" ]]; then

        command="test"

    elif [[ ${link_name} = "d" ]]; then

        command="deploy"

    else

        error "unknown link ${link_name}"
        exit 1
    fi

    process-common-arguments "$@" && set -- "${ARGS[@]}" || { echo "failed to process common arguments" 1>&2; exit 1; }

    ${HELP} && { display-help; exit 0; }

    do-${command} "$@"
}

function do-build() {

    debug "do-build() positional parameters: $@"

    local clean
    local no_tests
    local refresh_dependencies

    while [[ -n "$1" ]]; do

        if [[ "$1" = "-c" ]]; then

            clean="clean"

        elif [[ "$1" = "-r" ]]; then

            refresh_dependencies="--refresh-dependencies";

        elif [[ "$1" = "--no-tests" ]]; then

            no_tests="-x test"
        fi
        shift
    done

  local command="gradle ${clean} build ${no_tests} ${refresh_dependencies}"
  echo ${command}
  exec ${command}
}

#
# Optional configuration file. May contain:
#   Active Profile: active.profile=...
#
RCONFIG_FILE=$(pwd)/.rconfig

function do-run() {

    debug "${FUNCNAME[0]}($@)"

    local debug=false;
    local trace=false;
    local args

    while [[ -n $1 ]]; do

        if [[ $1 = "-d" || $1 = "--debug" ]]; then

            debug=true;

        elif [[ $1 = "--trace" ]]; then

            trace=true;

        else

            args="${args} $1"
        fi

        shift

    done

    local lib_dir=./build/libs

    check-whether-we-are-in-project-home-or-fail ${lib_dir}

    local jar=$(get-spring-boot-jar ${lib_dir})

    [[ -z "${jar}" ]] && fail "no Spring Boot JAR found in ${lib_dir}"

    if ${debug}; then

        debug_args="-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005";
        debug_flag="--debug"
    fi

    if ${trace}; then

        trace_flag="--trace"
    fi

    local active_profile=$(get-active-profile-from-rconfig)

    [[ -n "${active_profile}" ]] && active_profile_command_line="-Dspring.profiles.active=${active_profile}"

#    [ -z "${MAIN_CLASS}" ] && { echo "MAIN_CLASS variable not defined by the calling script" 1>&2; exit 1; }
#    [ -z "${CLASSPATH}" ] && { echo "CLASSPATH variable not defined by the calling script" 1>&2; exit 1; }
#    ${DEBUG} && debug_args="-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005";
#    java ${debug_args} -cp ${CLASSPATH} ${MAIN_CLASS} "$@"

    #if [ -z "${main_class}" ]; then
        #java ${debug_args} -jar ${jar} --spring.profiles.active=local
        #-Dspring.flyway.baselineOnMigrate=true
        echo java ${debug_args} ${active_profile_command_line} -jar "${jar}" ${debug_flag} ${trace_flag} ${args}
        java ${debug_args} ${active_profile_command_line} -jar "${jar}" ${debug_flag} ${trace_flag} ${args}
    #else
    #    java ${debug_args} -cp ${jar} ${main_class} ${debug_flag} ${trace_flag} ${args}
    #fi
}

function do-test() {

    fail "NOT YET IMPLEMENTED: uncomment do-test() and make sure the commented code works"

#    debug "do-test($@)"
#
#    local debug=false
#    local clean=false
#    local refresh_dependencies=false
#    local single_test
#
#    while [[ -n "$1" ]]; do
#
#        if [[ "$1" = "-d" ]]; then
#
#            debug=true;
#
#        elif [[ "$1" = "-c" ]]; then
#
#            clean=true;
#
#        elif [[ "$1" = "-r" ]]; then
#
#            refresh_dependencies=true;
#
#        elif [[ -z "${single_test}" ]]; then
#
#            single_test=$1
#        fi
#
#        shift
#    done
#
#    ${debug} && debug_opts="--debug-jvm"
#    [ -n "${single_test}" ] && single_test_spec="--tests ${single_test}"
#
#    ${clean} && clean_opt="clean"
#    ${refresh_dependencies} && refresh_dependencies_opt="--refresh-dependencies"
#
#    echo gradle ${clean_opt} test ${debug_opts} ${single_test_spec} ${refresh_dependencies_opt}
#    gradle ${clean_opt} test ${debug_opts} ${single_test_spec} ${refresh_dependencies_opt}
}

function check-whether-we-are-in-project-home-or-fail() {

    debug "${FUNCNAME[0]}($@)"

    local lib_dir=$1

    [[ -z ${lib_dir} ]] && fail "'lib_dir' not specified"
    [[ -d ${lib_dir} ]] || fail "$(pwd)/${lib_dir} directory not found. The script must be run from a project home ..."
}

#
# returns empty string if no JAR is found
#
function get-spring-boot-jar() {

    debug "${FUNCNAME[0]}($@)"

    local lib_dir=$1

    [[ -z ${lib_dir} ]] && fail "'lib_dir' not specified"

    find ${lib_dir} -name "*.jar"
}

# return empty string if .rconfig does not esist or it does not contain an active profile
function get-active-profile-from-rconfig() {

    [[ ! -f ${RCONFIG_FILE} ]] && return 0;

    cat ${RCONFIG_FILE} | grep "^active\.profile=" | sed -e 's/^.*=//'
}

RUNTIME_DIR=/Users/ovidiu/runtime

function do-deploy() {

    fail "NOT YET IMPLEMENTED: uncomment do-deploy() and make sure the commented code works"

#
#    local dir
#
#    dir=$(find-build-distributions-dir) || exit 1
#
#    [[ -z ${dir} ]] && { echo "[error]: no 'distributions' directory found in $(pwd) ... Has the project been built?" 1>&2; exit 1; }
#
#    local application_name=$(get-application-name)
#
#    debug "application name: ${application_name}"
#
#    [[ -z ${application_name} ]] && { echo "[error]: cannot figure out application name" 1>&2; exit 1; }
#
#    local distribution
#
#    distribution=$(find-zip-file ${dir} ${application_name}) || exit 1
#
#    debug "distribution: ${distribution}"
#
#    [[ -z ${distribution} ]] && { echo "[error]: no distribution ZIP file found in ${dir} ... Has the project been built?" 1>&2; exit 1; }
#
#    local version
#
#    version=$(get-version)
#
#    debug "version: ${version}"
#
#    [[ -n ${version} ]] && version="-${version}"
#
#    local top_directory_name=$(basename ${distribution} .zip)
#    debug "top directory: ${top_directory_name}"
#
#    [[ -d ${RUNTIME_DIR}/${top_directory_name} ]] && { rm -r ${RUNTIME_DIR}/${top_directory_name} && echo "${RUNTIME_DIR}/${top_directory_name} removed"; }
#
#    unzip -q ${distribution} -d ${RUNTIME_DIR} && echo "${top_directory_name} deployed in ${RUNTIME_DIR}"
#
#    (cd ${RUNTIME_DIR}; ln -sf ./${top_directory_name} ${application_name}) && echo "${application_name} linked to ${top_directory_name}"
}

function find-build-distributions-dir() {

    find $(pwd) -type d -name distributions
}

function find-zip-file () {

    local dir=$1
    local application_name=$2

    find ${dir} -type f -name ${application_name}'*.zip'
}

#
# return "" if version cannot be determined
#
function get-version () {

    local gradle_properties=$(pwd)/gradle.properties

    [[ ! -f ${gradle_properties} ]] && { echo "gradle.properties not found, cannot read version" 1>&2; return 1; }

    cat ${gradle_properties} | grep "^version" | sed -e 's/version=//'
}

#
# return "" if application name cannot be determined
#
function get-application-name () {

    local settings_gradle=$(pwd)/settings.gradle

    [[ ! -f ${settings_gradle} ]] && { echo "settings.gradle not found, cannot read application name" 1>&2; return 1; }

    local application_name=$(cat ${settings_gradle} | grep "^rootProject" | sed -e 's/^.*= *//')
    application_name=${application_name#\'}
    application_name=${application_name%\'}

    echo ${application_name}
}

main "$@"