#!/usr/bin/env bash

ld=$(dirname $0)/../lib
for i in bash.shlib jenkins.shlib; do [ -f ${ld}/${i} ] && source ${ld}/${i} || { echo "[error]: ${ld}/${i} not found" 1>&2; exit 1; } done

VERSION=0.1.3

PIPELINE_NAME=c3server-k8s
BRANCH=epic/cloud/team/k8sonly/develop

function usage() {
cat <<EOF

Collect logs for ${PIPELINE_NAME} pipeline runs on branch ${BRANCH}. The run (build) number and the
target directory must be specified as arguments.

Usage:

    $(basename $0) [options] <run-number> [target-dir]

If the target directory is not specified, the logs are collected in the current directory. If the target directory does
not exist, it will be created.

Options:

    -p|--pipeline <pipeline-name> Specifies the pipeline. The default is ${PIPELINE_NAME}.

    -b|--branch <branch> Specifies a branch. By default is ${BRANCH}.

    --preserve-tmp-dir Preserve temporary directories.


EOF
}
function main() {

    process-common-arguments "$@" && set -- "${ARGS[@]}" || { echo "failed to process common arguments" 1>&2; exit 1; }

    ${HELP} || [[ -z $1 ]] && { usage; exit 0; }

    unset ARGS; declare -a ARGS
    declare -A OPTIONS
    OPTIONS["--pipeline"]="string -p"
    OPTIONS["--branch"]="string -b"
    OPTIONS["--preserve-tmp-dir"]="boolean"
    process-options "$@"
    fail-on-unknown-arguments 2

    local pipeline=${OPTIONS["--pipeline"]:-${PIPELINE_NAME}}
    local branch=${OPTIONS["--branch"]:-${BRANCH}}
    local preserve_tmp_dir=${OPTIONS["--preserve-tmp-dir"]:false}

    local run_id=${ARGS[0]}
    local target_dir=${ARGS[1]:-$(pwd)}

    debug "pipeline: ${pipeline}"
    debug "branch: ${branch}"
    debug "run_id: ${run_id}"
    debug "target_dir: ${target_dir}"

    if [[ ! -d ${target_dir} ]]; then
        mkdir -p "${target_dir}" && info "created directory ${target_dir}" || fail "mkdir -p \"${target_dir}\" failed"
    fi

    local command="$(dirname $0)/jenq"
    ${VERBOSE} && command="${command} --verbose"
    ${preserve_tmp_dir} && command="${command} --preserve-tmp-dir"

    for node_id in $(${command} nodes ${pipeline} ${branch} ${run_id}); do

        debug "node_id: ${node_id}"

        #
        # TODO: querying again for name is inefficient, we can pull the JSON representation of all nodes in the outer loop
        #
        local node_name
        node_name=$(${command} node ${pipeline} ${branch} ${run_id} ${node_id} | jq -r '.displayName') || \
            fail "failed to read name for node ${node_id}"
        debug "node name: ${node_name}"

        if [[ ${node_name} = "Testing" ]]; then
            info "skipping logs for node \"${node_name}\""
            continue
        fi

        local target_file="${target_dir}/${node_id}-${node_name// /_}.log"
        ${command} log ${pipeline} ${branch} ${run_id} ${node_id} log > "${target_file}"
        info "collected logs for node \"${node_name}\" in $(basename "${target_file}")"
    done
}

main "$@"
